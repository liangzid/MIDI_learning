#include"STC12C5A60S2.H" //芯片头文件
typedef unsigned char uchar;
typedef unsigned int  uint; 
#define channel      0x01		  //设置AD通道为 P1.0
#define ADC_POWER   (1<<7) 
#define ADC_SPEEDHH (0x03<<5) 
#define ADC_START   (1<<3) 
#define PADCH       (1<<5) 
#define ADC_FLAG    (1<<4)

code char SIN_TAB[128]={0,6,12,18,24,30,36,42,48,54,59,65,70,75,80,85,89,94,98,102, 
                        105,108,112,114,117,119,121,123,124,125,126,126,126,126,126,
						125,124,123,121,119,117,114,112,108,105,102,98,94,89,85,80,75,
						70,65,59,54,48,42,36,30,24,18,12,6,0,-6,-12,-18,-24,-30,-36,-42,
						-48,-54,-59,-65,-70,-75,-80,-85,-89,-94,-98,-102,-105,-108,-112,
						-114,-117,-119,-121,-123,-124,-125,-126,-126,-126,-126,-126,-125,
						-124,-123,-121,-119,-117,-114,-112,-108,-105,-102,-98,-94,-89,-85,
						-80,-75,-70,-65,-59,-54,-48,-42,-36,-30,-24,-18,-12,-6};

//放大128倍后的cos整数表（128）
code char COS_TAB[128]={127,126,126,125,124,123,121,119,117,114,112,108,105,102,98,94, 
                        89,85,80,75,70,65,59,54,48,42,36,30,24,18,12,6,0,-6,-12,-18,-24,
						-30,-36,-42,-48,-54,-59,-65,-70,-75,-80,-85,-89,-94,-98,-102,
						-105,-108,-112,-114,-117,-119,-121,-123,-124,-125,-126,-126,-126,
						-126,-126,-125,-124,-123,-121,-119,-117,-114,-112,-108,-105,-102,
						-98,-94,-89,-85,-80,-75,-70,-65,-59,-54,-48,-42,-36,-30,-24,-18,
						-12,-6,0,6,12,18,24,30,36,42,48,54,59,65,70,75,80,85,89,94,98,102,
						105,108,112,114,117,119,121,123,124,125,126,126};

//采样存储序列表
code char LIST_TAB[128] = {0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,
                           12,76,44,108,28,92,60,124,2,66,34,98,18,82,50,114,10,74,42,106,26,90,58,
						   122,6,70,38,102,22,86,54,118,14,78,46,110,30,94,62,126,1,65,33,97,17,81,49,
						   113,9,73,41,105,25,89,57,121,5,69,37,101,21,85,53,117,13,77,45,109,29,93,61,
						   125,3,67,35,99,19,83,51,115,11,75,43,107,27,91,59,123,7,71,39,103,23,87,55,
						   119,15,79,47,111,31,95,63,127};
uchar i = 0,j = 0,k = 0;  	  //
uchar b = 0,p = 0;//anum; //  
int   Temp_Real = 0,Temp_Imag = 0,temp = 0;         //中间临时变量  
uint  TEMP1 = 0,maxa = 0;						//中间临时变量
int   xdata Fft_Real[128]; 				//FFT的实部
int   xdata Fft_Image[128];             //FFT的虚部 
uchar xdata LED_TAB[16];				//记录红色柱状 
void FFT() //基2fft
{                 
	for(i=1; i<=7; i++)                             /* for(1) */
	{ 
		b=1;
		b <<=(i-1);                                 //碟式运算，用于计算隔多少行计算例如 第一极 1和2行计算
		for(j=0; j<=b-1; j++)                      /* for (2) */
		{ 
			p=1;
			p <<= (7-i);            
			p = p*j;
			for(k=j; k<128; k=k+2*b)               /* for (3)  */
			{ 
				Temp_Real=Fft_Real[k];
				Temp_Imag=Fft_Image[k];
				temp=Fft_Real[k+b];
				Fft_Real[k]=Fft_Real[k]+((Fft_Real[k+b]*COS_TAB[p])>>7)+((Fft_Image[k+b]*SIN_TAB[p])>>7);
				Fft_Image[k]=Fft_Image[k]-((Fft_Real[k+b]*SIN_TAB[p])>>7)+((Fft_Image[k+b]*COS_TAB[p])>>7);
				Fft_Real[k+b]=Temp_Real-((Fft_Real[k+b]*COS_TAB[p])>>7)-((Fft_Image[k+b]*SIN_TAB[p])>>7);
				Fft_Image[k+b]=Temp_Imag+((temp*SIN_TAB[p])>>7)-((Fft_Image[k+b]*COS_TAB[p])>>7);          // 移位.防止溢出. 结果已经是本值的 1/64               
				Fft_Real[k] >>= 1;             
				Fft_Image[k] >>= 1; 
				Fft_Real[k+b] >>= 1;                 
				Fft_Image[k+b] >>= 1; 																													 
			}     
		} 
	} 

	for(j=0;j<16;j++) //16分频											 
	{																			  
		TEMP1=((((Fft_Real[j+1]* Fft_Real[j+1]))+((Fft_Image[j+1]*Fft_Image[j+1])))>>1);//求各频段幅值

		if(TEMP1<1) TEMP1=0; 
		LED_TAB[j]  = TEMP1;	

		if(LED_TAB[j]>maxa) maxa = LED_TAB[j];   //maxa是本次转换的最大值
	}
	if(maxa>16) //分级量化
	{
		maxa /= 16;
		for(j=0;j<16;j++) 
			LED_TAB[j] /= maxa;
			//LED_TAB[j] = 0;
	}       
}